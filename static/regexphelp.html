<h4>Спецсимволы в регулярном выражении</h4>
<table class="table table-condensed">
<tbody><tr class="info"><th width="20%">Символ</th><th width="80%">Значение</th></tr>
<tr>
<td><code>\</code></td>
<td>Для обычных символов - делает их специальными. Например, выражение <code>/s/</code> ищет просто символ 's'. А если поставить \ перед s, то <code>/\s/</code> уже обозначает пробельный символ.И наоборот, если символ специальный, например *, то \ сделает его просто обычным символом "звездочка". Например, <code>/a*/</code> ищет 0 или больше подряд идущих символов 'a'. Чтобы найти а со звездочкой 'a*' - поставим \ перед спец. символом: <code>/a\*/</code>.</td>
</tr>
<tr>
<td><code>^</code></td>
<td>Обозначает начало входных данных. Если установлен флаг многострочного поиска <code>("m")</code>, то также сработает при начале новой строки.Например, <code>/^A/</code> не найдет 'A' в "an A", но найдет первое 'A' в "An A."</td>
</tr>
<tr>
<td><code>$</code></td>
<td>Обозначает конец входных данных. Если установлен флаг многострочного поиска, то также сработает в конце строки.Например, <code>/t$/</code> не найдет 't' в "eater", но найдет - в "eat".</td>
</tr>
<tr>
<td><code>*</code></td>
<td>Обозначает повторение 0 или более раз. Например, <code>/bo*/</code> найдет 'boooo' в "A ghost booooed" и 'b' в "A bird warbled", но ничего не найдет в "A goat grunted".</td>
</tr>
<tr>
<td><code>+</code></td>
<td>Обозначает повторение 1 или более раз. Эквивалентно <code>{1,}</code>. Например, <code>/a+/</code> найдет 'a' в "candy" и все 'a' в "caaaaaaandy".</td>
</tr>
<tr>
<td><code>?</code></td>
<td>Обозначает, что элемент может как присутствовать, так и отсутствовать. Например, <code>/e?le?/</code> найдет 'el' в "angel" и 'le' в "angle."Если используется сразу после одного из <code>квантификаторов *</code>, <code>+</code>, <code>?</code>, или <code>{}</code>, то задает "нежадный" поиск (повторение минимально возможное количество раз, до ближайшего следующего элемента паттерна), в противоположность "жадному" режиму по умолчанию, при котором количество повторений максимально, даже если следующий элемент паттерна тоже подходит.Кроме того, ? используется в предпросмотре, который описан в таблице под <code>(?=)</code>, <code>(?!)</code>, и <code>(?: )</code>.</td>
</tr>
<tr>
<td><code>.</code></td>
<td>(Десятичная точка) обозначает любой символ, кроме перевода строки: \n \r \u2028 or \u2029. (<code>можно использовать [\s\S] для поиска любого символа, включая переводы строк). Например, </code><code>/.n/</code> найдет 'an' и 'on' в "nay, an apple is on the tree", но не 'nay'.</td>
</tr>
<tr>
<td><code>(<code>x</code>)</code></td>
<td>Находит <code><code>x</code></code> и запоминает. Это называется "запоминающие скобки". Например, <code>/(foo)/</code> найдет и запомнит 'foo' в "foo bar." Найденная подстрока хранится в массиве-результате поиска или в предопределенных свойствах объекта RegExp:<code></code><code></code> <code>$1, ..., $9</code>.Кроме того, скобки объединяют то, что в них находится, в единый элемент паттерна. Например, (abc)* - повторение abc 0 и более раз.</td>
</tr>
<tr>
<td><code>(?:<code>x</code>)</code></td>
<td>Находит <code><code>x</code></code>, но не запоминает найденное. Это называется "незапоминающие скобки". Найденная подстрока не сохраняется в массиве результатов и свойствах RegExp.Как и все скобки, объединяют находящееся в них в единый подпаттерн.</td>
</tr>
<tr>
<td><code><code>x</code>(?=<code>y</code>)</code></td>
<td>Находит <code><code>x</code></code>, только если за <code><code>x</code></code> следует <code><code>y</code></code>. Например, <code>/Jack(?=Sprat)/</code> найдет 'Jack', только если за ним следует 'Sprat'. <code>/Jack(?=Sprat|Frost)/</code> найдет 'Jack', только если за ним следует 'Sprat' или 'Frost'. Однако, ни 'Sprat' ни 'Frost' не войдут в результат поиска.</td>
</tr>
<tr>
<td><code><code>x</code>(?!<code>y</code>)</code></td>
<td>Находит <code><code>x</code></code>, только если за <code><code>x</code></code> не следует <code><code>y</code></code>. Например, <code>/\d+(?!\.)/</code> найдет число, только если за ним не следует десятичная точка. <code>/\d+(?!\.)/.exec("3.141")</code> найдет 141, но не 3.141.</td>
</tr>
<tr>
<td><code><code>x</code>|<code>y</code></code></td>
<td>Находит <code><code>x</code></code> или <code><code>y</code></code>. Например, <code>/green|red/</code> найдет 'green' в "green apple" и 'red' в "red apple."</td>
</tr>
<tr>
<td><code>{<code>n</code>}</code></td>
<td>Где n - положительное целое число. Находит ровно n повторений предшествующего элемента. Например, <code>/a{2}/</code> не найдет 'a' в "candy," но найдет оба a в "caandy," и первые два a в "caaandy."</td>
</tr>
<tr>
<td><code>{<code>n</code>,}</code></td>
<td>Где n - положительное целое число. Находит n и более повторений элемента. Например, <code>/a{2,}</code> не найдет 'a' в "candy", но найдет все 'a' в "caandy" и в "caaaaaaandy."</td>
</tr>
<tr>
<td><code>{<code>n</code>,<code>m</code>}</code></td>
<td>Где n и m - положительные целые числа. Находят от n до m повторений элемента.</td>
</tr>
<tr>
<td><code>[<code>xyz</code>]</code></td>
<td>Набор символов. Находит любой из перечисленных символов. Вы можете указать промежуток, используя тире. Например, <code>[abcd]</code> - то же самое, что <code>[a-d]</code>. Найдет 'b' в "brisket", а также 'a' и 'c' в "ache".</td>
</tr>
<tr>
<td><code>[^<code>xyz</code>]</code></td>
<td>Любой символ, кроме указанных в наборе. Вы также можете указать промежуток. Например, <code>[^abc]</code> - то же самое, что <code>[^a-c]</code>. Найдет 'r' в "brisket" и 'h' в "chop."</td>
</tr>
<tr>
<td><code>[\b]</code></td>
<td>Находит символ backspace. (Не путать с <code>\b</code>.)</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>Находит границу слов (латинских), например пробел. (Не путать с <code>[\b]</code>). Например, <code>/\bn\w/</code> найдет 'no' в "noonday"; <code>/\wy\b/</code> найдет 'ly' в "possibly yesterday."</td>
</tr>
<tr>
<td><code>\B</code></td>
<td>Обозначает не границу слов. Например, <code>/\w\Bn/</code> найдет 'on' в "noonday", а <code>/y\B\w/</code> найдет 'ye' в "possibly yesterday."</td>
</tr>
<tr>
<td><code>\c<code>X</code></code></td>
<td><code><code>Где </code></code><code><code>X</code></code> - буква от A до Z. Обозначает контрольный символ в строке. Например, <code>/\cM/</code> обозначает символ Ctrl-M.</td>
</tr>
<tr>
<td><code>\d</code></td>
<td>находит цифру из любого алфавита (у нас же юникод). Испльзуйте <code>[0-9], чтобы найти только обычные цифры. Например, </code><code>/\d/</code> или <code>/[0-9]/</code> найдет '2' в "B2 is the suite number."</td>
</tr>
<tr>
<td><code>\D</code></td>
<td>Найдет нецифровой символ (все алфавиты). <code>[^0-9]</code> - эквивалент для обычных цифр. Например, <code>/\D/</code> или <code>/[^0-9]/</code> найдет 'B' в "B2 is the suite number."</td>
</tr>
<tr>
<td><code>\f,\r,\n</code></td>
<td>Соответствующие спецсимволы form-feed, line-feed, перевод строки.</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>Найдет любой пробельный символ, включая пробел, табуляцию, переводы строки и другие юникодные пробельные символы. Например, <code>/\s\w*/</code> найдет ' bar' в "foo bar."</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>Найдет любой символ, кроме пробельного. Например, <code>/\S\w*/</code> найдет 'foo' в "foo bar."</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>Символ табуляции.</td>
</tr>
<tr>
<td><code>\v</code></td>
<td>Символ вертикальной табуляции.</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>Найдет любой словесный (латинский алфавит) символ, включая буквы, цифры и знак подчеркивания. Эквивалентно <code>[A-Za-z0-9_]</code>. Например, <code>/\w/</code> найдет 'a' в "apple," '5' в "$5.28," и '3' в "3D."</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>Найдет любой не-(лат.)словесный символ. Эквивалентно <code>[^A-Za-z0-9_]</code>. Например, <code>/\W/</code> и <code>/[^$A-Za-z0-9_]/</code> одинаково найдут '%' в "50%."</td>
</tr>
<tr>
<td><code>\<code>n</code></code></td>
<td>где <code><code>n</code></code> - целое число. Обратная ссылка на n-ю запомненную скобками подстроку. Например, <code>/apple(,)\sorange\1/</code> найдет 'apple, orange,' в "apple, orange, cherry, peach.". За таблицей есть более полный пример.</td>
</tr>
<tr>
<td><code>\0</code></td>
<td>Найдет символ NUL. Не добавляйте в конец другие цифры.</td>
</tr>
<tr>
<td><code>\x<code>hh</code></code></td>
<td>Найдет символ с кодом <code><code>hh</code></code> (2 шестнадцатиричных цифры)</td>
</tr>
<tr>
<td><code>\u<code>hhhh</code></code></td>
<td>Найдет символ с кодом <code><code>hhhh</code></code> (4 шестнадцатиричных цифры).</td>
</tr>
</tbody></table>


<h4>Спецсимволы в строке замены</h4>
<table class="table table-condensed">
<tbody><tr class="info"><th width="20%">Pattern</th><th width="80%">Inserts</th></tr>
<tr>
<td><code>$$</code></td>
<td>Вставляет "$".</td>
</tr>
<tr>
<td><code>$&amp;</code></td>
<td>Вставляет найденную подстроку.</td>
</tr>
<tr>
<td><code>$`</code></td>
<td>Вставляет часть строки, которая предшествует найденному вхождению.</td>
</tr>
<tr>
<td><code>$'</code></td>
<td>Вставляет часть строки, которая идет после найденного вхождения.</td>
</tr>
<tr>
<td style="white-space: nowrap"><code>$<code>n</code></code> or <code>$<code>nn</code></code></td>
<td>Где <code><code>n</code></code> или <code><code>nn</code></code> - десятичные цифры, вставляет подстроку вхождения, запомненную <code>n</code>-й вложенной скобкой, если первый аргумент - объект RegExp.</td>
</tr>
</tbody></table>